// Copyright (c) 2005 Broad Institute/Massachusetts Institute of Technology

#include "util/QCMarkup.h"
#include "util/QCMarkupIO.h"

#include "util/mutil.h"
#include <iostream>

QCMarkupIO::QCMarkupIO(QCMarkup & m)
{

  m_pM = &m;
}


QCMarkupIO::~QCMarkupIO()
{
}
  



bool QCMarkupIO::Read(const string & name)
{
  if (strstr(name.c_str(), ".bin") != NULL) {
    //cout << "Switch to binary file read: " << name << endl; 
    return ReadBinary(name);
  }

  
    //cout << "Switch to XML file read: " << name << endl; 
    return ReadXML(name);
    //} else {
    //cout << "Switch to binary file read: " << name + ".bin" << endl; 
    //return ReadBinary(name + ".bin");
    // }

}


//-----------------------------------------------------------------------
bool QCMarkupIO::ReadXML(const string & name)
{
  CMAsciiReadFileStream in;

  in.Open(name.c_str());

  CMString line;

  CMTokenizer tokenizer;
  tokenizer.AddDelimiter(" ");
  tokenizer.AddDelimiter("<");
  tokenizer.AddDelimiter(">");
  tokenizer.AddDelimiter("/>");
  tokenizer.AddDelimiter("=");


  QCMark m;




  int currsuper = 0;
  int maxSuper = 0;
  while (!in.IsEnd()) {
    in.ReadLine(line);
    if (in.IsEnd())
      break;
    
    CMPtrStringList tokens;
    tokenizer.Tokenize(tokens, line);
    if (tokens.length() == 0) {
      continue;
    }
    //cout << (const char*)line << endl;
    for (int i=0; i<tokens.length(); i++) {
      // Comments?
      if (*tokens(i) == "!--") {
	while (i<tokens.length() && *tokens(i) != "--") {
	  i++;
	} 
      }
      const CMString & t = *tokens(i);

      if (t == "supercontig") {
	//cout << "!!!!!!!!!!!!!!" << endl;
	currsuper = atol(*tokens(i+1));
	m.SetSuper(currsuper);
	i++;
	if (currsuper > maxSuper)
	  maxSuper = currsuper;
	if (maxSuper >= m_pM->m_superLen.isize()) {
	  m_pM->m_superLen.resize(maxSuper + 50000, 0);
	  m_pM->m_superMarkStart.resize(maxSuper + 50000, 0);
	  m_pM->m_superMarkStop.resize(maxSuper + 50000, 0);
	}
	continue;
      }

      if (t == "len") {
	m_pM->SetSuperLen(currsuper, atol(*tokens(i+1)));
	i++;
	continue;
      }

      if (t == "start") {
	int c = atol(*tokens(i+2));
	int b = atol(*tokens(i+4));
	int sb = atol(*tokens(i+6));
	i+= 6;
	m.SetContig(c);
	m.SetStartOnContig(b);
	m.SetStartOnSuper(sb);
	m.SetName("");
	m.SetType("");
	m.SetOrdering("");
	m.SetLocal("");
	continue;
      }
      if (t == "end") {
	int c = atol(*tokens(i+2));
	int b = atol(*tokens(i+4));
	int sb = atol(*tokens(i+6));
	i+= 6;
	m.SetContig2(c);
	m.SetEndOnContig(b);
	m.SetEndOnSuper(sb);
	m_pM->AddMark(m);
      	//m.Reset();
	continue;
      }
      if (t == "type") {
	const CMString & type = *tokens(i+1);
	m.SetType((const char*)type);
	i++;
	continue;
      }
	
      
      if (t == "name") {
 	const CMString & type = *tokens(i+1);
	m.SetName((const char*)type);
	i++;
	continue;
      }
      if (t == "order") {
 	const CMString & type = *tokens(i+1);
	m.SetOrdering((const char*)type);
	i++;
	continue;
      }
      if (t == "local") {
 	const CMString & type = *tokens(i+1);
	m.SetLocal((const char*)type);
	i++;
	continue;
      }
      if (t == "score") {
	int l = atol(*tokens(i+1));
	i++;
	m.SetLevel(l);
	continue;
      }
      //cout << (const char*)line << endl;
      //if (t == "/" && i+1 < tokens.length() && *tokens(i+1) == "supercontig") {
      //cout << "Adding mark..." << endl;
      //m_pM->AddMark(m);
      //	m.Reset();
      //i++;
      //continue;
      //}
    }
  }

  m_pM->m_superLen.resize(maxSuper + 1, 0);
  m_pM->m_superMarkStart.resize(maxSuper + 1, 0);
  m_pM->m_superMarkStop.resize(maxSuper + 1, 0);
  in.Close();
  m_pM->Sort();
  return true;
}

 
bool QCMarkupIO::WriteTrueXML(const string & name, bool bSuperCoords)
{
  cout << "Writing markup to " << name << endl;
  
  FILE * pFile = fopen(name.c_str(), "w");

  m_pM->Sort();

 
  int numSupers = m_pM->GetNumSupers();
  
  int i, j;
  

  fprintf(pFile, "<!-- Broad Institute/MIT assembly markup file - DO NOT EDIT! -->\n\n\n");
  fprintf(pFile, "<assembly>\n\n");

  int contig = -1;
  for (i=0; i<numSupers; i++) {
    int len = m_pM->GetSuperLen(i);
    int count = m_pM->GetCountForSuper(i);

    contig = -1;

    string superName = m_pM->GetSuperName(i);

    if (superName == "") {
      fprintf(pFile, "  <supercontig id=\"%d\"  len=\"%d\">\n", i, len); 
    } else {
      fprintf(pFile, "  <chromosome id=\"%s\"  len=\"%d\">\n", superName.c_str(), len);       
    }

    for (j=0; j<count; j++) {
      const QCMark & d = m_pM->GetMarkForSuper(i, j);

      if (d.GetContig() != contig) {
	if (contig != -1)
	  fprintf(pFile, "    </contig>\n\n"); 
	contig = d.GetContig();
	fprintf(pFile, "    <contig id=\"%d\">\n", contig); 
      }

      if (bSuperCoords) {
	if (superName == "") {
	  fprintf(pFile, "      <coordinates start=\"%d\"  stop=\"%d\"  superstart=\"%d\"  superstop=\"%d\">\n",
		  d.GetStartOnContig(),
		  d.GetEndOnContig(),
		  d.GetStartOnSuper(),
		  d.GetEndOnSuper());
	} else {
	  fprintf(pFile, "      <coordinates start=\"%d\"  stop=\"%d\"  chromosome_start=\"%d\"  chromosome_stop=\"%d\">\n",
		  d.GetStartOnContig(),
		  d.GetEndOnContig(),
		  d.GetStartOnSuper(),
		  d.GetEndOnSuper());
	}
      } else {
	fprintf(pFile, "      <coordinates start=\"%d\"  stop=\"%d\">\n",
		d.GetStartOnContig(),
		d.GetEndOnContig());
      }

      fprintf(pFile, "        <mark type=\"%s\"", d.GetType().c_str());
      if (d.GetName() != "")
	fprintf(pFile, "   name=\"%s\"", d.GetName().c_str());
      if (d.GetOrdering() != "")
	fprintf(pFile, "   order=\"%s\"", d.GetOrdering().c_str());
      if (d.GetLocal() != "")
	fprintf(pFile, "   local=\"%s\"", d.GetLocal().c_str());

      fprintf(pFile, "  score=\"%d\"/>\n", d.GetLevel());

      fprintf(pFile, "      </coordinates>\n");


    }
    if (contig != -1)
      fprintf(pFile, "    </contig>\n\n"); 
      
    if (superName == "") {
      fprintf(pFile, "  </supercontig>\n\n"); 
    } else {
      fprintf(pFile, "  </chromosome>\n\n"); 
    }
  }
  fprintf(pFile, "</assembly>\n\n");
  return true;
}

bool QCMarkupIO::WriteXML(const string & name)
{
  cout << "Writing markup to " << name << endl;

  FILE * pFile = fopen(name.c_str(), "w");

  m_pM->Sort();

  // Num supers?
  int numSupers = m_pM->GetNumSupers();
  
  int i, j;
  

  fprintf(pFile, "<!-- Broad Institute/MIT assembly markup file - DO NOT EDIT! -->\n\n\n");

  for (i=0; i<numSupers; i++) {
    int len = m_pM->GetSuperLen(i);
    int count = m_pM->GetCountForSuper(i);

    fprintf(pFile, "< supercontig %d   len = %d >\n", i, len); 


    for (j=0; j<count; j++) {
      const QCMark & d = m_pM->GetMarkForSuper(i, j);
      fprintf(pFile, "    < start contig = %d   base = %d   superbase = %d />\n",
	      d.GetContig(),
	      d.GetStartOnContig(),
	      d.GetStartOnSuper());
      
      fprintf(pFile, "        < type %s", d.GetType().c_str());
      if (d.GetName() != "")
	fprintf(pFile, "    name = %s", d.GetName().c_str());
      if (d.GetOrdering() != "")
	fprintf(pFile, "    order = %s", d.GetOrdering().c_str());
      if (d.GetLocal() != "")
	fprintf(pFile, "    local = %s", d.GetLocal().c_str());
      fprintf(pFile, "   score = %d />\n", d.GetLevel());



      fprintf(pFile, "    < end contig = %d   base = %d   superbase = %d />\n\n",
	      d.GetContig2(),
	      d.GetEndOnContig(),
	      d.GetEndOnSuper());
    }
    fprintf(pFile, "</ supercontig %d >\n\n\n", i); 
  }

  fclose(pFile);
  cout << "done!" << endl;
  return true;
}


#define BIN_VERSION 0x04030201

  
//-----------------------------------------------------------------------
bool QCMarkupIO::ReadBinary(const string & name)
{
  //cout << "Reading markup from " << name << endl;

  CMReadFileStream file;
  file.Open(name.c_str());

  // Num supers?
  int num;
  file.Read(num);

 
  int ver = 0;

  if (num == BIN_VERSION) {
    ver = 1;
    file.Read(num);
  }
  //cout << "Reading file version " << ver << endl;

  m_pM->SetNumSupers(num);
  
  int i;
  
  for (i=0; i<num; i++) {
    file.Read(m_pM->m_superLen[i]);
  }
  
  for (i=0; i<num; i++) {
    file.Read(m_pM->m_superMarkStart[i]);
  }
  for (i=0; i<num; i++) {
    file.Read(m_pM->m_superMarkStop[i]);
  }


  // Num anos?
  file.Read(num);

  
  m_pM->m_allMarks.resize(num);

  for (i=0; i<num; i++) {
    QCMark & d = m_pM->m_allMarks[i];
    int v;

    file.Read(v);
    d.SetContig(v);
  
    file.Read(v);
    d.SetContig2(v);
 
    file.Read(v);
    d.SetSuper(v); 

    file.Read(v);
    d.SetStartOnContig(v);

    file.Read(v);
    d.SetEndOnContig(v);

    file.Read(v);
    d.SetStartOnSuper(v);

    file.Read(v);
    d.SetEndOnSuper(v);

    file.Read(v);
    d.SetLevel(v);

    CMString s;
    file.Read(s);
    d.SetType((const char*)s);
    
    file.Read(s);
    d.SetName((const char*)s);

    file.Read(s);
    d.SetOrdering((const char*)s);
 
    if (ver >= 1) {
      file.Read(s);
      d.SetLocal((const char*)s);
    }
  }



  file.Close();
  //cout << "sorting..." << endl;
  m_pM->Sort();
  //cout << "done!" << endl;

  return true;
}

bool QCMarkupIO::WriteBinary(const string & name)
{

  cout << "Writing markup to " << name << endl;
  CMWriteFileStream file;
  file.Open(name.c_str());

  m_pM->Sort();


  int ver = BIN_VERSION;
  file.Write(ver);
 
  // Num supers?
  int num = m_pM->GetNumSupers();
  file.Write(num);
  
  int i;
  
  for (i=0; i<num; i++) {
    file.Write(m_pM->m_superLen[i]);
  }
  for (i=0; i<num; i++) {
    file.Write(m_pM->m_superMarkStart[i]);
  }
  for (i=0; i<num; i++) {
    file.Write(m_pM->m_superMarkStop[i]);
  }


  // Num anos?
  num = m_pM->GetNumMarks();
  file.Write(num);

  for (i=0; i<num; i++) {
    const QCMark & d = m_pM->GetMark(i);
   
    file.Write(d.GetContig());
    file.Write(d.GetContig2());
    file.Write(d.GetSuper());
    file.Write(d.GetStartOnContig());
    file.Write(d.GetEndOnContig());
    file.Write(d.GetStartOnSuper());
    file.Write(d.GetEndOnSuper());
    file.Write(d.GetLevel());
    CMString s = d.GetType().c_str();
    file.Write(s);
    s = d.GetName().c_str();
    file.Write(s);
    s = d.GetOrdering().c_str();
    file.Write(s);
    s = d.GetLocal().c_str();
    file.Write(s);
  }

  file.Close();
  cout << "done!" << endl;
  return true;
}
  
//-----------------------------------------------------------------------
//bool QCMarkupIO::ReadFlat(const string & name)
//{
//}

bool QCMarkupIO::WriteFlat(const string & name, bool bSupers)
{
  cout << "Writing markup to " << name << endl;
  FILE * pOut = fopen(name.c_str(), "w");
  
  m_pM->Sort();
  int num = m_pM->GetNumMarks();


  cout << "Num supers: " << m_pM->GetNumSupers() << endl;

  int i;
  for (i=0; i<num; i++) {
    const QCMark & d = m_pM->GetMark(i);
    //cout << i << endl;
    string annot = d.GetType();
    if (d.GetName() != "")
      annot += ":" + d.GetName();
    if (d.GetOrdering() != "")
      annot += ":" + d.GetOrdering();

    if (bSupers) {
      fprintf(pOut, "%d\t%d\t%d\t%s\t%d\t%d\t%d\t%d\n",
	      d.GetContig(),
	      d.GetStartOnSuper(),
	      d.GetEndOnSuper(),
	      annot.c_str(),
	      d.GetLevel(),
	      d.GetSuper(),
	      d.GetStartOnSuper(),
	      d.GetEndOnSuper());
  
    } else {

      fprintf(pOut, "%d\t%d\t%d\t%s\t%d\t%d\t%d\t%d\n",
	      d.GetContig(),
	      d.GetStartOnContig(),
	      d.GetEndOnSuper() - d.GetStartOnSuper() + d.GetStartOnContig(),
	      annot.c_str(),
	      d.GetLevel(),
	      d.GetSuper(),
	      d.GetStartOnSuper(),
	      d.GetEndOnSuper());
    }
  }

  fclose(pOut);
  cout << "done!" << endl;
  return true;
}

bool QCMarkupIO::WriteBED(const string & name)
{
  cout << "Writing markup to " << name << endl;
  FILE * pOut = fopen(name.c_str(), "w");
  
  m_pM->Sort();
  int num = m_pM->GetNumMarks();


  cout << "Num supers: " << m_pM->GetNumSupers() << endl;

  int i;
  for (i=0; i<num; i++) {
    const QCMark & d = m_pM->GetMark(i);
    //cout << i << endl;
    fprintf(pOut, "scaffold_%d\t%d\t%d\t%s\t%d\n",
	    d.GetSuper(),
	    d.GetStartOnSuper(),
	    d.GetEndOnSuper(),
	    d.GetType().c_str(),
	    d.GetLevel());

  }

  fclose(pOut);
  cout << "done!" << endl;
  return true;
  
}




bool QCMarkupIO::WriteGFF2(const string & name, bool bSuperCoords)
{
  vec<string> dummy;
  return WriteGFF2(name, bSuperCoords, dummy);
}


bool QCMarkupIO::WriteGFF2(const string & name, 
			   bool bSuperCoords, 
			   const vec<string> & superNames)

{
  cout << "Writing markup to " << name << endl;
  FILE * pOut = fopen(name.c_str(), "w");
  
  m_pM->Sort();
  int num = m_pM->GetNumMarks();



 
  int i;
  for (i=0; i<num; i++) {
    const QCMark & d = m_pM->GetMark(i);
    //cout << i << endl;
    string annot = d.GetType();
    if (d.GetName() != "")
      annot += ":" + d.GetName();
    if (d.GetOrdering() != "")
      annot += ":" + d.GetOrdering();

    if (bSuperCoords) {
      if (superNames.isize() == 0 || superNames[d.GetSuper()] == "") {
	fprintf(pOut, "scaffold_%d\tARACHNE\tqcmarkup\t%d\t%d\t%d\t.\t.\t%s\n",
		d.GetSuper(),
		//d.GetType().c_str(),
		d.GetStartOnSuper(),
		d.GetEndOnSuper()/* - d.GetStartOnSuper() + d.GetStartOnContig()*/,
		d.GetLevel(),
		annot.c_str());
      } else {
	fprintf(pOut, "%s\tARACHNE\tqcmarkup\t%d\t%d\t%d\t.\t.\t%s\n",
		superNames[d.GetSuper()].c_str(),
		//d.GetType().c_str(),
		d.GetStartOnSuper(),
		d.GetEndOnSuper()/* - d.GetStartOnSuper() + d.GetStartOnContig()*/,
		d.GetLevel(),
		annot.c_str());
      }
    } else {
     fprintf(pOut, "contig_%d\tARACHNE\tqcmarkup\t%d\t%d\t%d\t.\t.\t%s\n",
	      d.GetContig(),
	      //d.GetType().c_str(),
	      d.GetStartOnContig(),
	      d.GetEndOnSuper() - d.GetStartOnSuper() + d.GetStartOnContig(),
	      d.GetLevel(),
	      annot.c_str());

    }

  }

  fclose(pOut);
  cout << "done!" << endl;
  return true;
}

bool QCMarkupIO::WriteSimpleGFF(const string & name, 
				bool bSuperCoords)

{
  cout << "Writing markup to " << name << endl;
  FILE * pOut = fopen(name.c_str(), "w");
  
  m_pM->Sort();
  int num = m_pM->GetNumMarks();



 
  int i;
  for (i=0; i<num; i++) {
    const QCMark & d = m_pM->GetMark(i);
    //cout << i << endl;
    string annot = d.GetType();
    if (d.GetName() != "")
      annot += ":" + d.GetName();
    if (d.GetOrdering() != "")
      annot += ":" + d.GetOrdering();

    if (bSuperCoords) {
      
      fprintf(pOut, "%d\t%d\t%d\t%d\t%s\n",
	      d.GetSuper(),
	      //d.GetType().c_str(),
	      d.GetStartOnSuper(),
	      d.GetEndOnSuper()/* - d.GetStartOnSuper() + d.GetStartOnContig()*/,
	      d.GetLevel(),
	      annot.c_str());
    } else {
     fprintf(pOut, "contig_%d\t%d\t%d\t%d\t%s\n",
	      d.GetContig(),
	      //d.GetType().c_str(),
	      d.GetStartOnContig(),
	      d.GetEndOnSuper() - d.GetStartOnSuper() + d.GetStartOnContig(),
	      d.GetLevel(),
	      annot.c_str());

    }

  }

  fclose(pOut);
  cout << "done!" << endl;
  return true;
}
