// Copyright (c) 2005 Broad Institute/Massachusetts Institute of Technology


#include "util/QCOps.h"
#include <iostream>
/*
QCMarker::QCMarker(const Assembly & theAssembly) {
  m_pAssembly = &theAssembly;
}


void QCMarker::AddMark(QCMarkup & m, 
		       int super,
		       int from,
		       int to,
		       const String & type,
		       int score,
		       bool bContigify,
		       const String & name)
{
  int i;
  Super s = m_pAssembly->GetSuper(super);

  //cout << "Request to add " << type << " from " << from << " to " << to << " on super " << super << endl;

  svec<ContigLocation> vecCLs;
  s.GetContigLocations(vecCLs);
    

  int startContig = -1;
  int endContig = -1;

  int startOnContig = 0;
  int endOnContig = 0;

  QCMark mark;

  for (i=0; i<vecCLs.isize(); i++) {
    if (startContig != -1 && endContig != -1)
      break;

    ContigToken origContig = vecCLs[i].GetContig();
    int cID = origContig.GetId();    

    //cout << vecCLs[i].Begin() << " - " << to << " - " << vecCLs[i].End() << endl;

    if (startContig == -1 && vecCLs[i].Begin() - 1 <= from && vecCLs[i].End() + 1 >= from) {
      startContig = cID;
      startOnContig = from - vecCLs[i].Begin();
      if (startOnContig < 0)
	startOnContig = 0;
      if (startOnContig > vecCLs[i].End() - vecCLs[i].Begin())
	startOnContig = vecCLs[i].End() - vecCLs[i].Begin();
    }
    if (endContig == -1 && vecCLs[i].Begin() - 1 <= to && vecCLs[i].End() + 1 >= to) {
      //cout << "FOUND IT!!" << endl;
      endContig = cID;
      endOnContig = to - vecCLs[i].Begin();
      if (endOnContig < 0)
	endOnContig = 0;
      if (endOnContig > vecCLs[i].End() - vecCLs[i].Begin())
	endOnContig = vecCLs[i].End() - vecCLs[i].Begin();
    }
  } 
  

  if (!bContigify || startContig == endContig) {
    mark.SetContig(startContig);
    mark.SetContig2(endContig);
    mark.SetSuper(super);
    mark.SetStartOnContig(startOnContig);
    mark.SetEndOnContig(endOnContig);
    mark.SetStartOnSuper(from);
    mark.SetEndOnSuper(to);
    mark.SetLevel(score); 
    mark.SetType(type);
    mark.SetName(name);
    m.AddMark(mark);

  } else {
    for (i=0; i<vecCLs.isize(); i++) {
      ContigToken origContig = vecCLs[i].GetContig();
      int cID = origContig.GetId();
      //if (cID == 17241)
      //cout << "found it!" << endl;
      if (cID == startContig && startContig < vecCLs[i].End() - vecCLs[i].Begin()) {
	//if (cID == 17241)
	//cout << "Adding mark!!!!!" << endl;
	mark.SetContig(startContig);
	mark.SetContig2(startContig);
	mark.SetSuper(super);
	mark.SetStartOnContig(startOnContig);
	mark.SetEndOnContig(vecCLs[i].End() - vecCLs[i].Begin() - 1);
	mark.SetStartOnSuper(from);
	mark.SetEndOnSuper(vecCLs[i].End() - 1);
	mark.SetLevel(score); 
	mark.SetType(type);
	mark.SetName(name);
	m.AddMark(mark);

	continue;
      }
      if (cID == endContig && endOnContig >=0) {
	mark.SetContig(endContig);
	mark.SetContig2(endContig);
	mark.SetSuper(super);
	mark.SetStartOnContig(0);
	mark.SetEndOnContig(endOnContig);
	mark.SetStartOnSuper(vecCLs[i].Begin());
	mark.SetEndOnSuper(to);
	mark.SetLevel(score); 
	mark.SetType(type);
	mark.SetName(name);
	m.AddMark(mark);

	continue;
      }
      if (vecCLs[i].Begin() > from && vecCLs[i].End() < to) {

	mark.SetContig(cID);
	mark.SetContig2(cID);
	mark.SetSuper(super);
	mark.SetStartOnContig(0);
	mark.SetEndOnContig(vecCLs[i].End() - vecCLs[i].Begin() - 1);
	mark.SetStartOnSuper(vecCLs[i].Begin());
	mark.SetEndOnSuper(vecCLs[i].End() - 1);
	mark.SetLevel(score); 
	mark.SetType(type);
	mark.SetName(name);
	m.AddMark(mark);
     }
    }

  }


}


*/

void QCMarkupAppendMerger::Merge(QCMarkup & out,
				 const QCMarkup & in,
				 const String & exclude)
{

  int i, j;

  out.SetNumSupers(in.GetNumSupers());
 

  cout << "Merging markups..." << endl << endl;

  int bases = 0;
  for (i=0; i<in.GetNumSupers(); i++) {
    int len = in.GetSuperLen(i);
    out.SetSuperLen(i, len);

    int count = in.GetCountForSuper(i);
    
    for (j=0; j<count; j++) {
      if (exclude == "" || in.GetMarkForSuper(i, j).GetType() != exclude)
	out.AddMark(in.GetMarkForSuper(i, j));
    }
  }

  out.Sort();
}

void QCMarkupMerger::Merge(QCMarkup & out,
			   const QCMarkup & in,
			   const String & exclude,
			   int minLevel)
{

  
  int i, j;

  out.SetNumSupers(in.GetNumSupers());
 

  cout << "Merging markups..." << endl << endl;
  //cout << "Exclude " << exclude << endl;
  int bases = 0;
  for (i=0; i<in.GetNumSupers(); i++) {
    int len = in.GetSuperLen(i);
    out.SetSuperLen(i, len);

    int count = in.GetCountForSuper(i);
    
    for (j=0; j<count; j++) {
      QCMark newMark = in.GetMarkForSuper(i, j);
      //cout << "Starting with mark " << newMark.GetType() << " ends " << newMark.GetEndOnSuper() << endl;
      newMark.SetLevel(1);
      
      bool bGoAhead = false;
      if (exclude == "") {
	bGoAhead = true;
      } else {
	if (j+1 < count) { 
	  if (strstr(newMark.GetType().c_str(), exclude.c_str()) == NULL ||
	      strstr(in.GetMarkForSuper(i, j+1).GetType().c_str(), exclude.c_str()) == NULL)
	    bGoAhead = true;
	}
      }
      
      if (bGoAhead && minLevel > 0) {
	if (j+1 < count) { 
	  if (newMark.GetLevel() < minLevel &&
	      in.GetMarkForSuper(i, j+1).GetLevel() < minLevel)
	    bGoAhead = false;
	}
	
      }


      //if (exclude == "" || strstr(newMark.GetType().c_str(), exclude.c_str()) == NULL) { 
      if (bGoAhead) {
	//cout << "Next mark " << in.GetMarkForSuper(i, j+1).GetType();
	//cout << " starts " << in.GetMarkForSuper(i, j+1).GetStartOnSuper() << endl;
 	while (j+1<count && 
	       /*in.GetMarkForSuper(i, j+1).GetContig() == newMark.GetContig() &&*/
	       in.GetMarkForSuper(i, j+1).GetStartOnSuper() <= newMark.GetEndOnSuper() + m_slack) {
	  //cout << "  merging " << in.GetMarkForSuper(i, j+1).GetType() << endl;
	  if (in.GetMarkForSuper(i, j+1).GetEndOnSuper() > newMark.GetEndOnSuper()) {
	    newMark.SetEndOnContig(in.GetMarkForSuper(i, j+1).GetEndOnContig());
	    newMark.SetContig2(in.GetMarkForSuper(i, j+1).GetContig2());
	    newMark.SetEndOnSuper(in.GetMarkForSuper(i, j+1).GetEndOnSuper());
	  }
	  
	  if (strstr(newMark.GetType().c_str(), in.GetMarkForSuper(i, j+1).GetType().c_str()) == NULL
	      /*&& strlen(newMark.GetType().c_str()) < 512*/)
	    newMark.SetType(newMark.GetType() + "." + in.GetMarkForSuper(i, j+1).GetType());
	  newMark.SetLevel(newMark.GetLevel()+1);	
	  j++;
	}      
      }
      //j--;
      out.AddMark(newMark);
      bases += newMark.GetEndOnSuper() - newMark.GetStartOnSuper();
    }
  }
  cout << in.GetNumMarks() << " marks have been merged into " << out.GetNumMarks() << ", total bases: " << bases << "." << endl;

  out.Sort();
}



void QCMarkupFilter::AddException(const String & e)
{
  m_exceptions.push_back(e);
}


bool QCMarkupFilter::IsException(const String & s)
{
  int i;
  for (i=0; i<m_exceptions.isize(); i++) {
    if (m_exceptions[i] == s)
      return true;
  }
  return false;
}

void QCMarkupFilter::Filter(QCMarkup & out,
			    const QCMarkup & in,
			    int minLevel)
{


  int i, j;

  out.SetNumSupers(in.GetNumSupers());
 

  cout << "Filtering markup..." << endl;

  int bases = 0;
  for (i=0; i<in.GetNumSupers(); i++) {
    int len = in.GetSuperLen(i);
    out.SetSuperLen(i, len);

    int count = in.GetCountForSuper(i);
    
    for (j=0; j<count; j++) {
      const QCMark & m = in.GetMarkForSuper(i, j);
      if (m.GetLevel() >= minLevel || IsException(m.GetType())) {
	out.AddMark(m);
	//cout << "Adding mark..." << endl;
      }
    }
  }
  out.Sort();
  cout << in.GetNumMarks() << " marks have been filtered into " << out.GetNumMarks() << endl;

}






/*
void ContigifyMarkup(QCMarkup & out, 
		     const QCMarkup & markup, 
		     const Assembly & theAssembly)
{
  vec<int> contigIndex;
  vec<int> contigLen;

  contigIndex.resize(theAssembly.GetNumContigs(), -1);
  contigLen.resize(theAssembly.GetNumContigs(), 0);
  int i, j;

  out.SetNumSupers(markup.GetNumSupers());

  for (i=0; i<markup.GetNumSupers(); i++) {
    int len = markup.GetSuperLen(i);

    out.SetSuperLen(i, len);

    int count = markup.GetCountForSuper(i);
    
    Super super = theAssembly.GetSuper(i);
    vec<ContigLocation> vecCLs; 
    super.GetContigLocations(vecCLs);

    for (j=0; j<vecCLs.isize(); j++) {
      contigIndex[vecCLs[j].GetContig().GetId()] = j;
      contigLen[vecCLs[j].GetContig().GetId()] = vecCLs[j].End() - vecCLs[j].Begin();
    }

    for (j=0; j<count; j++) {
     QCMark m = markup.GetMarkForSuper(i, j);
      int c1 = m.GetContig();
      int c2 = m.GetContig2();


      int index1 = -1;
      if (c1 != -1)
	index1 = contigIndex[c1];
      int index2 = -1;
      if (c2 != -1)
	index2 = contigIndex[c2];
 
      if (c1 == -1) {
	if (c2 == -1)
	  continue;
	c1 = c2;
	index1 = contigIndex[c1];
 	m.SetStartOnContig(0);
      }
      if (c2 == -1) {
	if (c1 == -1)
	  continue;
 	c2 = c1;
	index2 = contigIndex[c2];
	m.SetEndOnContig(vecCLs[index1].End() - vecCLs[index1].Begin());
      }
      
      if (m.GetStartOnContig() < 0) {
	m.SetStartOnSuper(m.GetStartOnSuper() - m.GetStartOnContig()); //adjust super coords
	m.SetStartOnContig(0);
      }

      int cLenEnd = vecCLs[index2].End() - vecCLs[index2].Begin();
      if (m.GetEndOnContig() >= cLenEnd) {
	m.SetEndOnSuper(m.GetEndOnSuper() - m.GetEndOnContig() + cLenEnd - 1); //adjust super coords
	m.SetEndOnContig(cLenEnd - 1);
      }

      if (c1 == c2) {
	out.AddMark(m);
	continue;
      }

      int from = m.GetStartOnContig();
      int to = vecCLs[index1].End() - vecCLs[index1].Begin();
   
      if (from < 0)
	from = 0;
 
      
      QCMark n1 = m;
      n1.SetContig2(m.GetContig());
      n1.SetEndOnContig(to - 1);
      n1.SetEndOnSuper(vecCLs[index1].End() - 1);
      
      if (n1.GetStartOnContig() <= to-1)
	out.AddMark(n1);
  
      from = 0;
      to = m.GetEndOnContig();


      if (to >= vecCLs[index2].End() - vecCLs[index2].Begin())
	to = vecCLs[index2].End() - vecCLs[index2].Begin() - 1;

      QCMark n2 = m;
      n2.SetContig(m.GetContig2());
      n2.SetStartOnContig(0);
      n2.SetStartOnSuper(vecCLs[index2].Begin());
      
      if (n2.GetEndOnContig() >= 0)
	out.AddMark(n2);

      //cout << "Multicontig, c2..." << endl;
      for (int x=index1+1; x<index2; x++) {
	from = 0;
	to = vecCLs[x].End() - vecCLs[x].Begin();
	QCMark nm = m;
	nm.SetContig(vecCLs[x].GetContig().GetId());
	nm.SetContig2(vecCLs[x].GetContig().GetId());
	nm.SetStartOnContig(0);
	nm.SetEndOnContig(to - 1);
	nm.SetStartOnSuper(vecCLs[index2].Begin());
	nm.SetStartOnSuper(vecCLs[index2].End() - 1);
	out.AddMark(nm);
      }
    }
  }

  for (i=0; i<out.GetNumMarks(); i++) {
    QCMark & m = out.Mark(i);
    int cLen = contigLen[m.GetContig()];
    if (m.GetEndOnContig() >= cLen) {
      int minus = m.GetEndOnContig() - cLen + 1;
      m.SetEndOnContig(m.GetEndOnContig() - minus);
      m.SetEndOnSuper(m.GetEndOnSuper() - minus);
      if (m.GetStartOnContig() > m.GetEndOnContig())
	m.SetStartOnContig(m.GetEndOnContig());
      if (m.GetStartOnSuper() > m.GetEndOnSuper())
	m.SetStartOnSuper(m.GetEndOnSuper());
      
    }
  }

}
*/
